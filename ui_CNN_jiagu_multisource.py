# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'CNN_jiagu_multisource.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtGui import QIcon
import time
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
from torch.autograd import Variable
from tqdm import trange
import numpy as np
import matplotlib.pyplot as plt
import torch
from torchvision import datasets, models, transforms
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.Qt import QThread,QImage
from PyQt5.Qt import pyqtSignal
from trades import trades_loss,at_loss
from tqdm import tqdm
from sklearn.metrics import confusion_matrix
from torch.utils.data import TensorDataset,DataLoader
from torch.utils.data import DataLoader, Dataset
from byol_pytorch import BYOL,DBYOL
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")


class Ui_Form_jiagu_multisource(object):
    def setupUi(self, Form_jiagu_multisource):
        Form_jiagu_multisource.setObjectName("Form_jiagu_multisource")
        Form_jiagu_multisource.resize(1398, 652)
        self.label_image_show_models = QtWidgets.QLabel(Form_jiagu_multisource)
        self.label_image_show_models.setGeometry(QtCore.QRect(840, 90, 521, 431))
        self.label_image_show_models.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_image_show_models.setText("")
        self.label_image_show_models.setObjectName("label_image_show_models")
        self.frame_3 = QtWidgets.QFrame(Form_jiagu_multisource)
        self.frame_3.setGeometry(QtCore.QRect(100, 340, 641, 41))
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")
        self.radioButton_DTRADES = QtWidgets.QRadioButton(self.frame_3)
        self.radioButton_DTRADES.setGeometry(QtCore.QRect(240, 10, 129, 16))
        self.radioButton_DTRADES.setObjectName("radioButton_DTRADES")
        self.radioButton_DAT = QtWidgets.QRadioButton(self.frame_3)
        self.radioButton_DAT.setGeometry(QtCore.QRect(50, 10, 145, 16))
        self.radioButton_DAT.setChecked(True)
        self.radioButton_DAT.setObjectName("radioButton_DAT")
        self.radioButton_DBYOL = QtWidgets.QRadioButton(self.frame_3)
        self.radioButton_DBYOL.setGeometry(QtCore.QRect(410, 10, 147, 16))
        self.radioButton_DBYOL.setObjectName("radioButton_DBYOL")
        self.frame_2 = QtWidgets.QFrame(Form_jiagu_multisource)
        self.frame_2.setGeometry(QtCore.QRect(100, 250, 681, 51))
        self.frame_2.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")
        self.radioButton_so2sat = QtWidgets.QRadioButton(self.frame_2)
        self.radioButton_so2sat.setGeometry(QtCore.QRect(50, 20, 101, 16))
        self.radioButton_so2sat.setChecked(True)
        self.radioButton_so2sat.setObjectName("radioButton_so2sat")
        self.frame = QtWidgets.QFrame(Form_jiagu_multisource)
        self.frame.setGeometry(QtCore.QRect(130, 120, 631, 80))
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.radioButton_densenet121 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_densenet121.setGeometry(QtCore.QRect(360, 10, 115, 31))
        self.radioButton_densenet121.setAutoExclusive(True)
        self.radioButton_densenet121.setObjectName("radioButton_densenet121")
        self.radioButton_vgg19 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_vgg19.setGeometry(QtCore.QRect(190, 30, 86, 41))
        self.radioButton_vgg19.setAutoExclusive(True)
        self.radioButton_vgg19.setObjectName("radioButton_vgg19")
        self.radioButton_alexnet = QtWidgets.QRadioButton(self.frame)
        self.radioButton_alexnet.setGeometry(QtCore.QRect(530, 10, 115, 31))
        self.radioButton_alexnet.setAutoExclusive(True)
        self.radioButton_alexnet.setObjectName("radioButton_alexnet")
        self.radioButton_resnet50 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_resnet50.setGeometry(QtCore.QRect(20, 35, 151, 31))
        self.radioButton_resnet50.setAutoExclusive(True)
        self.radioButton_resnet50.setObjectName("radioButton_resnet50")
        self.radioButton_vgg16 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_vgg16.setGeometry(QtCore.QRect(190, 10, 115, 31))
        self.radioButton_vgg16.setAutoExclusive(True)
        self.radioButton_vgg16.setObjectName("radioButton_vgg16")
        self.radioButton_mobilenet = QtWidgets.QRadioButton(self.frame)
        self.radioButton_mobilenet.setGeometry(QtCore.QRect(530, 30, 115, 41))
        self.radioButton_mobilenet.setAutoExclusive(True)
        self.radioButton_mobilenet.setObjectName("radioButton_mobilenet")
        self.radioButton_resnet18 = QtWidgets.QRadioButton(self.frame)
        self.radioButton_resnet18.setGeometry(QtCore.QRect(20, 5, 115, 31))
        self.radioButton_resnet18.setChecked(True)
        self.radioButton_resnet18.setAutoExclusive(True)
        self.radioButton_resnet18.setObjectName("radioButton_resnet18")
        self.radioButton_squeezenet = QtWidgets.QRadioButton(self.frame)
        self.radioButton_squeezenet.setGeometry(QtCore.QRect(360, 30, 161, 41))
        self.radioButton_squeezenet.setAutoExclusive(True)
        self.radioButton_squeezenet.setObjectName("radioButton_squeezenet")
        self.label_56 = QtWidgets.QLabel(Form_jiagu_multisource)
        self.label_56.setGeometry(QtCore.QRect(100, 200, 161, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_56.setFont(font)
        self.label_56.setObjectName("label_56")
        self.training_show = QtWidgets.QLabel(Form_jiagu_multisource)
        self.training_show.setGeometry(QtCore.QRect(80, 430, 711, 141))
        self.training_show.setStyleSheet("background-color: rgb(127, 130, 136);\n"
"")
        self.training_show.setFrameShadow(QtWidgets.QFrame.Raised)
        self.training_show.setLineWidth(3)
        self.training_show.setText("")
        self.training_show.setScaledContents(False)
        self.training_show.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.training_show.setObjectName("training_show")
        self.label_58 = QtWidgets.QLabel(Form_jiagu_multisource)
        self.label_58.setGeometry(QtCore.QRect(100, 300, 251, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_58.setFont(font)
        self.label_58.setObjectName("label_58")
        self.pushButton_train = QtWidgets.QPushButton(Form_jiagu_multisource)
        self.pushButton_train.setGeometry(QtCore.QRect(390, 390, 75, 23))
        self.pushButton_train.setObjectName("pushButton_train")
        self.label_57 = QtWidgets.QLabel(Form_jiagu_multisource)
        self.label_57.setGeometry(QtCore.QRect(100, 80, 231, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_57.setFont(font)
        self.label_57.setObjectName("label_57")

        self.retranslateUi(Form_jiagu_multisource)
        QtCore.QMetaObject.connectSlotsByName(Form_jiagu_multisource)

    def retranslateUi(self, Form_jiagu_multisource):
        _translate = QtCore.QCoreApplication.translate
        Form_jiagu_multisource.setWindowTitle(_translate("Form_jiagu_multisource", "Proactive Defense with Multi-Source RSIs"))
        Form_jiagu_multisource.setWindowIcon(QIcon("./1.ico"))
        self.radioButton_DTRADES.setText(_translate("Form_jiagu_multisource", "DTRADES"))
        self.radioButton_DAT.setText(_translate("Form_jiagu_multisource", "DAT"))
        self.radioButton_DBYOL.setText(_translate("Form_jiagu_multisource", "DBYOL"))
        self.radioButton_so2sat.setText(_translate("Form_jiagu_multisource", "So2Sat"))
        self.radioButton_densenet121.setText(_translate("Form_jiagu_multisource", "DenseNet121"))
        self.radioButton_vgg19.setText(_translate("Form_jiagu_multisource", "VGG19"))
        self.radioButton_alexnet.setText(_translate("Form_jiagu_multisource", "AlexNet"))
        self.radioButton_resnet50.setText(_translate("Form_jiagu_multisource", "ResNet50"))
        self.radioButton_vgg16.setText(_translate("Form_jiagu_multisource", "VGG16"))
        self.radioButton_mobilenet.setText(_translate("Form_jiagu_multisource", "MobileNet"))
        self.radioButton_resnet18.setText(_translate("Form_jiagu_multisource", "ResNet18"))
        self.radioButton_squeezenet.setText(_translate("Form_jiagu_multisource", "SqueezeNet"))
        self.label_56.setText(_translate("Form_jiagu_multisource", "Data："))
        self.label_58.setText(_translate("Form_jiagu_multisource", "Proactive Defense Methods："))
        self.pushButton_train.setText(_translate("Form_jiagu_multisource", "Start"))
        self.label_57.setText(_translate("Form_jiagu_multisource", "Model Selection:"))
    def caolianjie(self):
        self.pushButton_train.clicked.connect(self.clear_all)
        self.pushButton_train.clicked.connect(
            lambda: self.CNN_jiagu_multisource(
                self.radioButton_resnet18.isChecked(),
                self.radioButton_resnet50.isChecked(),
                self.radioButton_vgg16.isChecked(),
                self.radioButton_vgg19.isChecked(),
                self.radioButton_densenet121.isChecked(),
                self.radioButton_squeezenet.isChecked(),
                self.radioButton_alexnet.isChecked(),
                self.radioButton_mobilenet.isChecked(),
                self.radioButton_so2sat.isChecked(),
                self.radioButton_DAT.isChecked(),
                self.radioButton_DTRADES.isChecked(),
                self.radioButton_DBYOL.isChecked(),
            ))


    def clear_all(self):

        self.training_show.setText('Start defense')
        self.label_image_show_models.setPixmap(QtGui.QPixmap(""))
        self.label_image_show_models.repaint()

    def get_CNN_jiagu_multisource_result(self, result):
        self.training_show.setText('Done\n Accuracy: {}'.format(result[5]))
        self.training_show.repaint()

        test_cm = result[0]

        plt.rcParams['font.sans-serif'] = ['SimHei']
        plt.rcParams['axes.unicode_minus'] = False


        plt.imshow(test_cm, interpolation='nearest', cmap=plt.cm.Oranges)
        # plt.title('混淆矩阵')
        plt.colorbar()
        sub_dir = result[1]
        indices = range(len(sub_dir))
        plt.xticks(indices, sub_dir)
        plt.xticks(rotation = 90)
        plt.yticks(indices, sub_dir)
        plt.tick_params(labelsize=8)
        print(test_cm.shape)
        print(test_cm)
        print(len(sub_dir))
        iters = np.reshape([[[i, j] for j in range(len(sub_dir))] for i in range(len(sub_dir))], (test_cm.size, 2))
        if result[2] == 'mstar':
            type_size = 9
        elif result[2] == 'uc':
            type_size = 5
        elif result[2] == 'so2sat':
            type_size = 12
        for i, j in iters:
            plt.text(j, i, '%.0f' % (test_cm[i, j]), horizontalalignment='center',
                     verticalalignment='center', fontdict={'size': type_size, 'color': 'black'})
        plt.xlabel('Predicted Labels')
        plt.ylabel('True Labels')
        plt.tight_layout()
        plt.savefig('result_image/{}_{}_{}.jpg'.format(result[2],result[3],result[4]))
        plt.close('all')
        self.openimage_label_image_show_models('result_image/{}_{}_{}.jpg'.format(result[2],result[3],result[4]))






    def CNN_jiagu_multisource(self, resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
            alexnet_ifuse, mobilenet_ifuse, so2sat_ifuse,dat_ifuse,dtrades_ifuse,dbyol_ifuse
                  ):

        self.thread_CNN_jiagu_multisource = Thread_CNN_jiagu_multisource(resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
            alexnet_ifuse, mobilenet_ifuse, so2sat_ifuse,dat_ifuse,dtrades_ifuse,dbyol_ifuse
                                                 )
        self.thread_CNN_jiagu_multisource.update_jiagu_multisource.connect(self.get_CNN_jiagu_multisource_result)
        self.thread_CNN_jiagu_multisource.start()
        self.thread_CNN_jiagu_multisource.exec()

    def openimage_label_image_show_models(self, imgName):
        imgName = imgName.replace('\\', '/')

        jpg = QtGui.QPixmap(imgName).scaled(self.label_image_show_models.width(), self.label_image_show_models.height())
        self.label_image_show_models.setPixmap(jpg)
        self.label_image_show_models.repaint()

class Thread_CNN_jiagu_multisource(QThread):
    update_jiagu_multisource = pyqtSignal(dict)

    def __init__(self,
                 resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
                 alexnet_ifuse, mobilenet_ifuse, so2sat_ifuse,  dat_ifuse,
                 dtrades_ifuse,dbyol_ifuse
                 ):
        super().__init__()

        self.resnet18_ifuse, self.resnet50_ifuse, self.vgg16_ifuse, self.vgg19_ifuse, self.densenet121_ifuse, \
        self.squeezenet_ifuse,self.alexnet_ifuse, self.mobilenet_ifuse, self.so2sat_ifuse, self.dat_ifuse,self.dtrades_ifuse,self.dbyol_ifuse = \
            resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,\
            alexnet_ifuse, mobilenet_ifuse, so2sat_ifuse,  dat_ifuse,dtrades_ifuse,dbyol_ifuse

    def run(self):

        test_result = self.image_jiagu_all()
        self.update_jiagu_multisource.emit(test_result)
    def image_jiagu_all(self):

        if self.resnet18_ifuse:
            model_name='resnet18'
        if self.resnet50_ifuse:
            model_name='resnet50'
        if self.vgg16_ifuse:
            model_name='vgg16'
        if self.vgg19_ifuse:
            model_name='vgg19'
        if self.densenet121_ifuse:
            model_name='densenet121'
        if self.squeezenet_ifuse:
            model_name='squeezenet'
        if self.alexnet_ifuse:
            model_name='alexnet'
        if self.mobilenet_ifuse:
            model_name='mobilenet'

        if self.so2sat_ifuse:
            data_name = 'so2sat'
            sub_dir = ['居民区','工业区','林区','沙地','水体']
            mean = 0
            std = 1
            dataloaders_opt, dataloaders_sar, dataset_sizes = self.load_so2sat()

        model_opt_ori = self.model_load(model=model_name, dataset='so2satopt',ifpretrained=False)
        model_sar_ori = self.model_load(model=model_name, dataset='so2satsar',ifpretrained=False)
        if self.dat_ifuse:
            jiagu_method_name = 'at'
            model_opt_yijiagu = self.train_model_at(model_opt_ori,dataloaders_opt,mean,std,num_epochs=100)
            model_sar_yijiagu = self.train_model_at(model_sar_ori,dataloaders_sar,mean,std,num_epochs=100)
        elif self.dtrades_ifuse:
            jiagu_method_name = 'trades'
            model_opt_yijiagu = self.train_model_trades(model_opt_ori,dataloaders_opt,mean,std,num_epochs=20)
            model_sar_yijiagu = self.train_model_trades(model_sar_ori,dataloaders_sar,mean,std,num_epochs=20)
        elif self.dbyol_ifuse:
            jiagu_method_name = 'dbyol'
            model_opt_yijiagu,model_sar_yijiagu = self.train_model_dbyol(num_epochs=20)

        torch.save(model_opt_yijiagu,'pths/{}_opt_{}_{}.pth'.format(data_name,model_name,jiagu_method_name))
        torch.save(model_sar_yijiagu,'pths/{}_sar_{}_{}.pth'.format(data_name,model_name,jiagu_method_name))
        test_cleandata_cm,correct = self.test(model_opt_yijiagu,dataloaders_opt['val'],dataset_sizes['val'])
        return({0:test_cleandata_cm,1:sub_dir,2:data_name,3:model_name,4:jiagu_method_name,5:correct})
    def test(self,model,dataloders,dataset_sizes):
        model.eval()
        running_corrects = 0.0

        # Iterate over data.
        preds_all = np.zeros(dataset_sizes)
        labels_all = np.zeros(dataset_sizes)
        i = 0
        for data in tqdm(dataloders):
            # get the inputs
            inputs, labels = data
            # wrap them in Variable
            inputs = Variable(inputs.to(device))
            labels = Variable(labels.to(device))
            # zero the parameter gradients
            outputs = model(inputs)
            _, preds = torch.max(outputs.data, 1)
            running_corrects += torch.sum(preds == labels.data).to(torch.float32)
            preds_all[i*preds.shape[0]:(i+1)*preds.shape[0]] = preds.cpu().detach().numpy()
            labels_all[i * preds.shape[0]: (i + 1) * preds.shape[0]] = labels.cpu().detach().numpy()
            i+=1
        correct = running_corrects/dataset_sizes
        test_cm = confusion_matrix(labels_all, preds_all)
        return test_cm,correct
    def train_model_at(self,model, dataloder, mean,std, num_epochs=100):
        since = time.time()
        best_model_wts = model.state_dict()
        best_acc = 0.0
        optimizer = optim.Adam(model.parameters(), lr=0.001)
        scheduler = lr_scheduler.StepLR(optimizer, step_size=19, gamma=0.9)
        model.to(device)
        for epoch in trange(num_epochs):
            print('Epoch {}/{}'.format(epoch + 1, num_epochs))
            print('-' * 10)
            # Each epoch has a training and validation phase
            for phase in ['train', 'val']:
                if phase == 'train':
                    scheduler.step()
                    model.train(True)  # Set model to training mode
                else:
                    model.train(False)  # Set model to evaluate mode
                    model.eval()
                # Iterate over data.
                for data in dataloder[phase]:
                    # get the inputs
                    inputs, labels = data
                    inputs = Variable(inputs.to(device))
                    labels = Variable(labels.to(device)
                                      )
                    # zero the parameter gradients
                    optimizer.zero_grad()
                    loss = at_loss(model=model,
                                   x_natural=inputs,
                                   y=labels,
                                   optimizer=optimizer,
                                   mean=mean,
                                   std=std,
                                   step_size=1 / 255,
                                   epsilon=4 / 255,
                                   perturb_steps=20,
                                   )
                    # backward + optimize only if in training phase
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
            time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))
        # load best model weights
        model.load_state_dict(best_model_wts)
        return model

    def train_model_trades(self,model, dataloder, mean,std, num_epochs=100):
        model.to(device)
        since = time.time()
        best_model_wts = model.state_dict()
        best_acc = 0.0
        optimizer = optim.Adam(model.parameters(), lr=0.001)
        scheduler = lr_scheduler.StepLR(optimizer, step_size=19, gamma=0.9)
        for epoch in trange(num_epochs):
            print('Epoch {}/{}'.format(epoch + 1, num_epochs))
            print('-' * 10)
            # Each epoch has a training and validation phase
            for phase in ['train', 'val']:
                if phase == 'train':
                    scheduler.step()
                    model.train(True)  # Set model to training mode
                else:
                    model.train(False)  # Set model to evaluate mode
                    model.eval()
                # Iterate over data.
                for data in dataloder[phase]:
                    # get the inputs
                    inputs, labels = data
                    inputs = Variable(inputs.to(device))
                    labels = Variable(labels.to(device)
                                      )
                    # zero the parameter gradients
                    optimizer.zero_grad()
                    loss = trades_loss(model=model,
                                   x_natural=inputs,
                                   y=labels,
                                   optimizer=optimizer,
                                   mean=mean,
                                   std=std,
                                   step_size=0.005,
                                   epsilon=0.01,
                                   perturb_steps=5,
                                       beta=1.0
                                   )
                    # backward + optimize only if in training phase
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
            time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))
        # load best model weights
        model.load_state_dict(best_model_wts)
        return model

    def train_model(self,model, dataloder, num_epochs=100):
        model.to(device)
        since = time.time()
        best_model_wts = model.state_dict()
        best_acc = 0.0
        optimizer = optim.Adam(model.parameters(), lr=0.001)
        scheduler = lr_scheduler.StepLR(optimizer, step_size=19, gamma=0.9)
        criterion = nn.CrossEntropyLoss()
        for epoch in trange(num_epochs):
            print('Epoch {}/{}'.format(epoch + 1, num_epochs))
            print('-' * 10)
            # Each epoch has a training and validation phase
            for phase in ['train', 'val']:
                if phase == 'train':
                    scheduler.step()
                    model.train(True)  # Set model to training mode
                else:
                    model.train(False)  # Set model to evaluate mode
                    model.eval()
                # Iterate over data.
                for data in dataloder[phase]:
                    # get the inputs
                    inputs, labels = data
                    inputs = Variable(inputs.to(device))
                    labels = Variable(labels.to(device)
                                      )
                    # zero the parameter gradients
                    optimizer.zero_grad()
                    outputs = model(inputs)
                    _, preds = torch.max(outputs.data, 1)
                    loss = criterion(outputs, labels)
                    # backward + optimize only if in training phase
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
            time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))
        # load best model weights
        model.load_state_dict(best_model_wts)
        return model

    def train_model_dbyol(self,num_epochs=100):
        # print('2222')
        npy_root = 'Data\\So2sat\\'
        root1 = npy_root + '20000rgb5.npy'
        root2 = npy_root + 'train_so2sat_rgb_pgd_001.npy'
        root3 = npy_root + '20000vvfilter5.npy'
        root4 = npy_root + 'train_so2sat_sar_sar005.npy'
        ds = self.npy2Dataset(root1=root1,root2=root2,root3=root3,root4=root4)
        train_loader = DataLoader(ds, batch_size=256, num_workers=0, shuffle=True)
        net_rgb = self.model_load(model='resnet18', dataset='so2satopt', ifpretrained=False)
        net_sar = self.model_load(model='resnet18', dataset='so2satsar', ifpretrained=False)
        learner = DBYOL(net_rgb.to(device), net_sar.to(device), image_size=32, hidden_layer='avgpool', use_momentum=False)
        learner = learner.to(device)
        opt = torch.optim.SGD(learner.parameters(), lr=0.05, weight_decay=0.0004, momentum=0.9)
        running_loss = 0.0
        with torch.enable_grad():
            for i in tqdm(range(2)):
                for data in train_loader:
                    inputs1, inputs2, inputs3, inputs4 = data
                    # inputs1 = data
                    inputs1 = inputs1.to(device)
                    inputs2 = inputs2.to(device)
                    inputs3 = inputs3.to(device)
                    inputs4 = inputs4.to(device)
                    # inputs2 = inputs2.repeat(1,3,1,1)
                    # inputs1 = inputs1.repeat(1,3,1,1)
                    loss = learner(inputs1, inputs2, inputs3, inputs4)
                    # loss = learner(inputs1)
                    opt.zero_grad()
                    loss.backward()
                    opt.step()
                    # learner.update_moving_average()
                    running_loss += loss.item()
                if (i + 1) % 100 == 0:
                    torch.save(net_rgb.state_dict(), 'checkpoint/opt_dbyol_pre_{}epoch.pth'.format(i + 1))
                    # torch.save(learner.state_dict(),'So2Sat_DSI_learner/learner_so2sat0.05_32_BYOLDSI_resnet18_{}epoch.pth'.format(i+1))
                    torch.save(net_sar.state_dict(), 'checkpoint/sar_dbyol_pre_{}epoch.pth'.format(i + 1))
        dataloaders_opt, dataloaders_sar, dataset_sizes = self.load_so2sat()
        dataloaders_opt2,  dataset_sizes2 = self.load_so2sat2()

        # model_opt_yijiagu = self.train_model(net_rgb, dataloaders_opt, num_epochs=5)
        model_opt_yijiagu = self.train_model(net_rgb, dataloaders_opt2, num_epochs=5)




        return model_opt_yijiagu,net_sar
    class npy2Dataset(Dataset):
            def __init__(self, root1, root2, root3, root4, transform=None, sar_transform=None):
                # super(npy2Dataset, self).__init__()
                rgb1_data = np.load(root1)
                rgb2_data = np.load(root2)
                sar1_data = np.load(root3)
                sar1_data = sar1_data[:, :, :, np.newaxis]
                sar2_data = np.load(root4)
                rgb1_data = np.transpose(rgb1_data, (0, 3, 1, 2))
                sar1_data = np.transpose(sar1_data, (0, 3, 1, 2))
                print(sar1_data.shape, sar2_data.shape, rgb1_data.shape, rgb2_data.shape)
                sar1_data = np.float32(sar1_data)
                sar2_data = np.float32(sar2_data)
                rgb1_data = np.float32(rgb1_data)
                rgb2_data = np.float32(rgb2_data)
                # self.label = np.int64(lab)
                self.rgb1_data = rgb1_data
                self.rgb2_data = rgb2_data
                self.sar1_data = sar1_data
                self.sar2_data = sar2_data
                self.transform = transform
                self.sar_transform = sar_transform

            def __getitem__(self, index):
                rgb1_data = self.rgb1_data[index]
                rgb2_data = self.rgb2_data[index]
                sar1_data = self.sar1_data[index]
                sar2_data = self.sar2_data[index]

                # target = self.label[index]
                # target = np.array(target)
                # img1 = np.transpose(img1,(2,1,0))
                # img1 = Image.fromarray(np.uint8(img1))

                pos_1 = torch.from_numpy(rgb1_data)
                pos_2 = torch.from_numpy(rgb2_data)
                pos_3 = torch.from_numpy(sar1_data)
                pos_4 = torch.from_numpy(sar2_data)

                return pos_1, pos_2, pos_3, pos_4

            def __len__(self):
                return len(self.rgb1_data)
    def model_load(self, model='vgg16', dataset='mstar', ifpretrained=True):
        if model == 'vgg16':
            if dataset == 'mstar':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        if model == 'vgg19':
            if dataset == 'mstar':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet18':
            if dataset == 'mstar':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'so2satsar':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'uc':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)
            elif dataset == 'so2satopt':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet50':
            if dataset == 'mstar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'so2satsar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'uc':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)
            elif dataset == 'so2satopt':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'squeezenet':
            if dataset == 'mstar':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 10, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'so2satsar':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 5, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'uc':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 21, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'so2satopt':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 5, kernel_size=(1, 1), stride=(1, 1))
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'alexnet':
            if dataset == 'mstar':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'densenet121':
            if dataset == 'mstar':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=10, bias=True)
            if dataset == 'so2satsar':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'densenet201':
            if dataset == 'mstar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'inceptionv3':
            if dataset == 'mstar':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 10)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 10)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 21)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 21)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'mnasnet1_0':
            if dataset == 'mstar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'mobilenet':
            if dataset == 'mstar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'shufflenet_v2':
            if dataset == 'mstar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=5, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        # else:
        #     print('输入有误，请做好检查')

        return model_ft


    def load_so2sat(self, model='vgg16', batch_size=16):
        x_train_opt = np.load('Data\\so2sat\\20000rgb5.npy')
        x_train_sar = np.load('Data\\so2sat\\20000vvfilter5.npy')
        y_train = np.load('Data\\so2sat\\20000lab0-5.npy')

        x_val_opt = np.load('Data\\so2sat\\10608rgb5.npy')
        x_val_sar = np.load('Data\\so2sat\\10608vvfilter5.npy')
        y_val = np.load('Data\\so2sat\\10607testlab0-5.npy')

        x_train_opt = np.transpose(x_train_opt, (0, 3, 1, 2))
        x_val_opt = np.transpose(x_val_opt, (0, 3, 1, 2))

        x_train_sar = x_train_sar[:, :, :, np.newaxis]
        x_val_sar = x_val_sar[:, :, :, np.newaxis]
        x_train_sar = np.transpose(x_train_sar, (0, 3, 1, 2))
        x_val_sar = np.transpose(x_val_sar, (0, 3, 1, 2))

        a = torch.from_numpy(x_train_opt).to(torch.float32)
        b = torch.from_numpy(y_train)
        c = torch.from_numpy(x_val_opt).to(torch.float32)
        d = torch.from_numpy(y_val)
        train_opt_ids = TensorDataset(a, b)
        train_loader_opt = DataLoader(dataset=train_opt_ids, batch_size=1024, shuffle=True)
        val_opt_ids = TensorDataset(c, d)
        val_loader_opt = DataLoader(dataset=val_opt_ids, batch_size=1024, shuffle=False)
        dataloaders_opt = {'train': train_loader_opt, 'val': val_loader_opt}

        m = torch.from_numpy(x_train_sar).to(torch.float32)
        n = torch.from_numpy(x_val_sar).to(torch.float32)
        train_sar_ids = TensorDataset(m, b)
        train_loader_sar = DataLoader(dataset=train_sar_ids, batch_size=1024, shuffle=True)
        val_sar_ids = TensorDataset(n, d)
        val_loader_sar = DataLoader(dataset=val_sar_ids, batch_size=1024, shuffle=False)
        dataloaders_sar = {'train': train_loader_sar, 'val': val_loader_sar}

        dataset_sizes = {'train': len(train_sar_ids), 'val': len(val_sar_ids)}
        return dataloaders_opt, dataloaders_sar, dataset_sizes
    def load_so2sat2(self, model='vgg16', batch_size=16):
        x_train_opt = np.load('Data\\so2sat\\train_so2sat_rgb_pgd_001.npy')
        y_train = np.load('Data\\so2sat\\20000lab0-5.npy')
        x_val_opt = np.load('Data\\so2sat\\10608rgb5.npy')
        y_val = np.load('Data\\so2sat\\10607testlab0-5.npy')
        x_val_opt = np.transpose(x_val_opt, (0, 3, 1, 2))
        x_train_opt2 = np.load('Data\\so2sat\\20000rgb5.npy')
        y_train2 = np.load('Data\\so2sat\\20000lab0-5.npy')
        x_train_opt2 = np.transpose(x_train_opt2, (0, 3, 1, 2))
        x_train_opt = np.vstack((x_train_opt,x_train_opt,x_train_opt2))
        y_train = np.hstack((y_train,y_train,y_train2))

        a = torch.from_numpy(x_train_opt).to(torch.float32)
        b = torch.from_numpy(y_train)
        c = torch.from_numpy(x_val_opt).to(torch.float32)
        d = torch.from_numpy(y_val)
        train_opt_ids = TensorDataset(a, b)
        train_loader_opt = DataLoader(dataset=train_opt_ids, batch_size=1024, shuffle=True)
        val_opt_ids = TensorDataset(c, d)
        val_loader_opt = DataLoader(dataset=val_opt_ids, batch_size=1024, shuffle=False)
        dataloaders_opt = {'train': train_loader_opt, 'val': val_loader_opt}



        dataset_sizes = {'train': len(train_opt_ids), 'val': len(val_opt_ids)}
        return dataloaders_opt, dataset_sizes

if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    train = QtWidgets.QDialog()
    ui = Ui_Form_jiagu_multisource()
    ui.setupUi(train)
    ui.caolianjie()
    train.show()
    sys.exit(app.exec_())