# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'CNN_train_fugaishi.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from torch.utils.data import TensorDataset,DataLoader
import matplotlib.pyplot as plt
from PyQt5.QtGui import QIcon
import torch
from torchvision import datasets, models, transforms
from PyQt5 import QtCore, QtGui, QtWidgets
from openpyxl import load_workbook
from PyQt5.Qt import QThread
from PyQt5 import Qt
from PyQt5.Qt import pyqtSignal,QImageReader
import os
import time
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
from torch.autograd import Variable
from tqdm import trange
import numpy as np
import pyttsx3
import matplotlib as mpl
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")


class Ui_Form_train_fugaishi(object):
    def setupUi(self, Form_train_fugaishi):
        Form_train_fugaishi.setObjectName("Form_train_fugaishi")
        Form_train_fugaishi.resize(1294, 827)
        self.tabWidget = QtWidgets.QTabWidget(Form_train_fugaishi)
        self.tabWidget.setGeometry(QtCore.QRect(70, 80, 781, 341))
        self.tabWidget.setObjectName("tabWidget")
        self.tab_singlesource = QtWidgets.QWidget()
        self.tab_singlesource.setObjectName("tab_singlesource")
        self.radioButton_resnet50 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_resnet50.setGeometry(QtCore.QRect(70, 95, 151, 31))
        self.radioButton_resnet50.setAutoExclusive(False)
        self.radioButton_resnet50.setObjectName("radioButton_resnet50")
        self.radioButton_resnet18 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_resnet18.setGeometry(QtCore.QRect(70, 65, 115, 31))
        self.radioButton_resnet18.setChecked(True)
        self.radioButton_resnet18.setAutoExclusive(False)
        self.radioButton_resnet18.setObjectName("radioButton_resnet18")
        self.radioButton_densenet121 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_densenet121.setGeometry(QtCore.QRect(410, 70, 115, 31))
        self.radioButton_densenet121.setAutoExclusive(False)
        self.radioButton_densenet121.setObjectName("radioButton_densenet121")
        self.radioButton_vgg19 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_vgg19.setGeometry(QtCore.QRect(240, 90, 86, 41))
        self.radioButton_vgg19.setAutoExclusive(False)
        self.radioButton_vgg19.setObjectName("radioButton_vgg19")
        self.radioButton_squeezenet = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_squeezenet.setGeometry(QtCore.QRect(410, 90, 161, 41))
        self.radioButton_squeezenet.setAutoExclusive(False)
        self.radioButton_squeezenet.setObjectName("radioButton_squeezenet")
        self.radioButton_vgg16 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_vgg16.setGeometry(QtCore.QRect(240, 70, 115, 31))
        self.radioButton_vgg16.setAutoExclusive(False)
        self.radioButton_vgg16.setObjectName("radioButton_vgg16")
        self.label_57 = QtWidgets.QLabel(self.tab_singlesource)
        self.label_57.setGeometry(QtCore.QRect(20, 20, 391, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_57.setFont(font)
        self.label_57.setObjectName("label_57")
        self.radioButton_alexnet = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_alexnet.setGeometry(QtCore.QRect(580, 70, 115, 31))
        self.radioButton_alexnet.setAutoExclusive(False)
        self.radioButton_alexnet.setObjectName("radioButton_alexnet")
        self.radioButton_mobilenet = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_mobilenet.setGeometry(QtCore.QRect(580, 90, 115, 41))
        self.radioButton_mobilenet.setAutoExclusive(False)
        self.radioButton_mobilenet.setObjectName("radioButton_mobilenet")
        self.label_56 = QtWidgets.QLabel(self.tab_singlesource)
        self.label_56.setGeometry(QtCore.QRect(20, 160, 161, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_56.setFont(font)
        self.label_56.setObjectName("label_56")
        self.radioButton_fusarship = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_fusarship.setGeometry(QtCore.QRect(430, 210, 121, 16))
        self.radioButton_fusarship.setObjectName("radioButton_fusarship")
        self.radioButton_UC = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_UC.setGeometry(QtCore.QRect(190, 210, 89, 16))
        self.radioButton_UC.setObjectName("radioButton_UC")
        self.radioButton_mstar = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_mstar.setGeometry(QtCore.QRect(70, 210, 101, 16))
        self.radioButton_mstar.setChecked(True)
        self.radioButton_mstar.setObjectName("radioButton_mstar")
        self.radioButton_fgsc23 = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_fgsc23.setGeometry(QtCore.QRect(290, 210, 121, 16))
        self.radioButton_fgsc23.setObjectName("radioButton_fgsc23")
        self.pushButton_train = QtWidgets.QPushButton(self.tab_singlesource)
        self.pushButton_train.setGeometry(QtCore.QRect(320, 260, 75, 23))
        self.pushButton_train.setObjectName("pushButton_train")
        self.radioButton_sortedcars = QtWidgets.QRadioButton(self.tab_singlesource)
        self.radioButton_sortedcars.setGeometry(QtCore.QRect(580, 210, 131, 16))
        self.radioButton_sortedcars.setObjectName("radioButton_sortedcars")
        self.tabWidget.addTab(self.tab_singlesource, "")
        self.tab_multisource = QtWidgets.QWidget()
        self.tab_multisource.setObjectName("tab_multisource")
        self.pushButton_train_2 = QtWidgets.QPushButton(self.tab_multisource)
        self.pushButton_train_2.setGeometry(QtCore.QRect(310, 260, 75, 23))
        self.pushButton_train_2.setObjectName("pushButton_train_2")
        self.label_58 = QtWidgets.QLabel(self.tab_multisource)
        self.label_58.setGeometry(QtCore.QRect(20, 160, 161, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_58.setFont(font)
        self.label_58.setObjectName("label_58")
        self.radioButton_vgg19_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_vgg19_2.setGeometry(QtCore.QRect(240, 90, 86, 41))
        self.radioButton_vgg19_2.setAutoExclusive(False)
        self.radioButton_vgg19_2.setObjectName("radioButton_vgg19_2")
        self.radioButton_squeezenet_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_squeezenet_2.setGeometry(QtCore.QRect(410, 90, 161, 41))
        self.radioButton_squeezenet_2.setAutoExclusive(False)
        self.radioButton_squeezenet_2.setObjectName("radioButton_squeezenet_2")
        self.label_59 = QtWidgets.QLabel(self.tab_multisource)
        self.label_59.setGeometry(QtCore.QRect(20, 20, 381, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        self.label_59.setFont(font)
        self.label_59.setObjectName("label_59")
        self.radioButton_So2Sat = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_So2Sat.setGeometry(QtCore.QRect(70, 210, 101, 16))
        self.radioButton_So2Sat.setChecked(False)
        self.radioButton_So2Sat.setObjectName("radioButton_So2Sat")
        self.radioButton_resnet50_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_resnet50_2.setGeometry(QtCore.QRect(70, 95, 151, 31))
        self.radioButton_resnet50_2.setAutoExclusive(False)
        self.radioButton_resnet50_2.setObjectName("radioButton_resnet50_2")
        self.radioButton_resnet18_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_resnet18_2.setGeometry(QtCore.QRect(70, 65, 115, 31))
        self.radioButton_resnet18_2.setChecked(True)
        self.radioButton_resnet18_2.setAutoExclusive(False)
        self.radioButton_resnet18_2.setObjectName("radioButton_resnet18_2")
        self.radioButton_vgg16_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_vgg16_2.setGeometry(QtCore.QRect(240, 70, 115, 31))
        self.radioButton_vgg16_2.setAutoExclusive(False)
        self.radioButton_vgg16_2.setObjectName("radioButton_vgg16_2")
        self.radioButton_alexnet_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_alexnet_2.setGeometry(QtCore.QRect(580, 70, 115, 31))
        self.radioButton_alexnet_2.setAutoExclusive(False)
        self.radioButton_alexnet_2.setObjectName("radioButton_alexnet_2")
        self.radioButton_mobilenet_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_mobilenet_2.setGeometry(QtCore.QRect(580, 90, 115, 41))
        self.radioButton_mobilenet_2.setAutoExclusive(False)
        self.radioButton_mobilenet_2.setObjectName("radioButton_mobilenet_2")
        self.radioButton_densenet121_2 = QtWidgets.QRadioButton(self.tab_multisource)
        self.radioButton_densenet121_2.setGeometry(QtCore.QRect(410, 70, 115, 31))
        self.radioButton_densenet121_2.setAutoExclusive(False)
        self.radioButton_densenet121_2.setObjectName("radioButton_densenet121_2")
        self.tabWidget.addTab(self.tab_multisource, "")
        self.label_image_show_models = QtWidgets.QLabel(Form_train_fugaishi)
        self.label_image_show_models.setGeometry(QtCore.QRect(70, 430, 381, 351))
        self.label_image_show_models.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_image_show_models.setText("")
        self.label_image_show_models.setObjectName("label_image_show_models")
        self.label_image_show_epochs = QtWidgets.QLabel(Form_train_fugaishi)
        self.label_image_show_epochs.setGeometry(QtCore.QRect(870, 430, 381, 351))
        self.label_image_show_epochs.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_image_show_epochs.setText("")
        self.label_image_show_epochs.setObjectName("label_image_show_epochs")
        self.label_image_show_batchsize = QtWidgets.QLabel(Form_train_fugaishi)
        self.label_image_show_batchsize.setGeometry(QtCore.QRect(470, 430, 381, 351))
        self.label_image_show_batchsize.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_image_show_batchsize.setText("")
        self.label_image_show_batchsize.setObjectName("label_image_show_batchsize")
        self.training_show = QtWidgets.QLabel(Form_train_fugaishi)
        self.training_show.setGeometry(QtCore.QRect(870, 100, 381, 311))
        self.training_show.setStyleSheet("background-color: rgb(127, 130, 136);\n"
"")
        self.training_show.setFrameShadow(QtWidgets.QFrame.Raised)
        self.training_show.setLineWidth(3)
        self.training_show.setText("")
        self.training_show.setScaledContents(False)
        self.training_show.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.training_show.setObjectName("training_show")

        self.retranslateUi(Form_train_fugaishi)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Form_train_fugaishi)

    def retranslateUi(self, Form_train_fugaishi):
        _translate = QtCore.QCoreApplication.translate
        Form_train_fugaishi.setWindowTitle(_translate("Form_train_fugaishi", "Train Model with Best Choice"))
        Form_train_fugaishi.setWindowIcon(QIcon("./1.ico"))
        self.radioButton_resnet50.setText(_translate("Form_train_fugaishi", "ResNet50"))
        self.radioButton_resnet18.setText(_translate("Form_train_fugaishi", "ResNet18"))
        self.radioButton_densenet121.setText(_translate("Form_train_fugaishi", "DenseNet121"))
        self.radioButton_vgg19.setText(_translate("Form_train_fugaishi", "VGG19"))
        self.radioButton_squeezenet.setText(_translate("Form_train_fugaishi", "SqueezeNet"))
        self.radioButton_vgg16.setText(_translate("Form_train_fugaishi", "VGG16"))
        self.label_57.setText(_translate("Form_train_fugaishi", "Model Selection（Multiple options available）:"))
        self.radioButton_alexnet.setText(_translate("Form_train_fugaishi", "AlexNet"))
        self.radioButton_mobilenet.setText(_translate("Form_train_fugaishi", "MobileNet"))
        self.label_56.setText(_translate("Form_train_fugaishi", "Data："))
        self.radioButton_fusarship.setText(_translate("Form_train_fugaishi", "  FUSAR-Ship"))
        self.radioButton_UC.setText(_translate("Form_train_fugaishi", "UC"))
        self.radioButton_mstar.setText(_translate("Form_train_fugaishi", "  MSTAR"))
        self.radioButton_fgsc23.setText(_translate("Form_train_fugaishi", "  FGSC-23"))
        self.pushButton_train.setText(_translate("Form_train_fugaishi", "Train"))
        self.radioButton_sortedcars.setText(_translate("Form_train_fugaishi", "AID"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_singlesource), _translate("Form_train_fugaishi", "Single-Source"))
        self.pushButton_train_2.setText(_translate("Form_train_fugaishi", "Train"))
        self.label_58.setText(_translate("Form_train_fugaishi", "Data："))
        self.radioButton_vgg19_2.setText(_translate("Form_train_fugaishi", "VGG19"))
        self.radioButton_squeezenet_2.setText(_translate("Form_train_fugaishi", "SqueezeNet"))
        self.label_59.setText(_translate("Form_train_fugaishi", "Model Selection（Multiple options available）:"))
        self.radioButton_So2Sat.setText(_translate("Form_train_fugaishi", "So2Sat"))
        self.radioButton_resnet50_2.setText(_translate("Form_train_fugaishi", "ResNet50"))
        self.radioButton_resnet18_2.setText(_translate("Form_train_fugaishi", "ResNet18"))
        self.radioButton_vgg16_2.setText(_translate("Form_train_fugaishi", "VGG16"))
        self.radioButton_alexnet_2.setText(_translate("Form_train_fugaishi", "AlexNet"))
        self.radioButton_mobilenet_2.setText(_translate("Form_train_fugaishi", "MobileNet"))
        self.radioButton_densenet121_2.setText(_translate("Form_train_fugaishi", "DenseNet121"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_multisource), _translate("Form_train_fugaishi", "Multi-Source"))


    def caolianjie(self):
        self.pushButton_train.clicked.connect(self.clear_all)
        self.pushButton_train.clicked.connect(
            lambda: self.CNN_train_fugaishi_singlesource(
                self.radioButton_resnet18.isChecked(),
                self.radioButton_resnet50.isChecked(),
                self.radioButton_vgg16.isChecked(),
                self.radioButton_vgg19.isChecked(),
                self.radioButton_densenet121.isChecked(),
                self.radioButton_squeezenet.isChecked(),
                self.radioButton_alexnet.isChecked(),
                self.radioButton_mobilenet.isChecked(),
                self.radioButton_mstar.isChecked(),
                self.radioButton_UC.isChecked(),
                self.radioButton_fgsc23.isChecked(),
                self.radioButton_fusarship.isChecked(),
                self.radioButton_sortedcars.isChecked()
            ))
        self.pushButton_train_2.clicked.connect(self.clear_all)
        self.pushButton_train_2.clicked.connect(
            lambda: self.CNN_train_fugaishi_multisource(
                self.radioButton_resnet18_2.isChecked(),
                self.radioButton_resnet50_2.isChecked(),
                self.radioButton_vgg16_2.isChecked(),
                self.radioButton_vgg19_2.isChecked(),
                self.radioButton_densenet121_2.isChecked(),
                self.radioButton_squeezenet_2.isChecked(),
                self.radioButton_alexnet_2.isChecked(),
                self.radioButton_mobilenet_2.isChecked(),
                self.radioButton_So2Sat.isChecked()

            ))

    def clear_all(self):
        self.training_show.setText('')
        self.label_image_show_models.setPixmap(QtGui.QPixmap(""))
        self.label_image_show_models.repaint()
        self.label_image_show_batchsize.setPixmap(QtGui.QPixmap(""))
        self.label_image_show_batchsize.repaint()
        self.label_image_show_epochs.setPixmap(QtGui.QPixmap(""))
        self.label_image_show_epochs.repaint()

    def CNN_train_fugaishi_singlesource(
            self, resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
            alexnet_ifuse, mobilenet_ifuse, mstar_ifuse, uc_ifuse, fgsc23_ifuse, fusarship_ifuse,sortedcar_ifuse
    ):
        self.thread_CNN_train_fugaishi_singlesource = Thread_CNN_train_fugaishi_singlesource(
            resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
            alexnet_ifuse, mobilenet_ifuse, mstar_ifuse, uc_ifuse, fgsc23_ifuse, fusarship_ifuse,sortedcar_ifuse

        )
        ###xugai
        self.thread_CNN_train_fugaishi_singlesource.update_train_fugaishi_singlesource.connect(
            self.get_CNN_train_result_fugaishi_singlesource)
        self.thread_CNN_train_fugaishi_singlesource.start()
        self.thread_CNN_train_fugaishi_singlesource.exec()

        # return ({0: models_list, 1: acc_list_models, 2: model_best_name, 3: best_acc_batchsize, 4: acc_list_epochs_best,5:acc_list_batchsize})

    def CNN_train_fugaishi_multisource(
            self, resnet18_ifuse_2, resnet50_ifuse_2, vgg16_ifuse_2, vgg19_ifuse_2, densenet121_ifuse_2, squeezenet_ifuse_2,
            alexnet_ifuse_2, mobilenet_ifuse_2, so2sat_ifuse
    ):
        self.thread_CNN_train_fugaishi_multisource = Thread_CNN_train_fugaishi_multisource(
            resnet18_ifuse_2, resnet50_ifuse_2, vgg16_ifuse_2, vgg19_ifuse_2, densenet121_ifuse_2, squeezenet_ifuse_2,
            alexnet_ifuse_2, mobilenet_ifuse_2, so2sat_ifuse

        )
        ###xugai
        self.thread_CNN_train_fugaishi_multisource.update_train_fugaishi_multisource.connect(
            self.get_CNN_train_result_fugaishi_multisource)
        self.thread_CNN_train_fugaishi_multisource.start()
        self.thread_CNN_train_fugaishi_multisource.exec()


    mpl.rcParams["font.sans-serif"] = ["SimHei"]
    mpl.rcParams["axes.unicode_minus"] = False

    def get_CNN_train_result_fugaishi_singlesource(self, result):
        self.training_show.setText('Best model:'+str(result[2])
                                   +'\n'+'Best batch size:'+str(result[3])
                                   +'\n'+'Best epoch:'+str(result[6][0][0]+1)
                                   )
        self.training_show.repaint()

        engine = pyttsx3.init()
        engine.say('已训练完毕，最优模型为')

        # engine.say(image_test_result[4])

        engine.runAndWait()
        ##设定batchsize,要与模型统一385,397行
        num_epochs = 10
        xxxx = np.arange(num_epochs) + 1
        z1 = np.polyfit(xxxx, result[4], 3)  # 用4次多项式拟合
        p1 = np.poly1d(z1)
        yvals1 = p1(xxxx)
        plt.figure(figsize=(3,2.25))
        plot1_2 = plt.plot(xxxx, yvals1, 'b-p')

        plt.xlabel('Epoch')
        plt.ylabel('Accuracy rates')
        plt.savefig(r'result_image/{}_epoch.jpg'.format(result[2]))
        self.openimage_label_image_show_epochs('result_image/{}_epoch.jpg'.format(result[2]))

        plt.cla()
        plt.figure(figsize=(3,2.25))
        bar_width = 0.5
        bs_list_str = list(['16', '32', '64', '128','256'])
        plt.bar(np.arange(len(bs_list_str)), np.array(result[5]), bar_width, align="center")
        plt.xlabel("Batch_size")
        plt.ylabel("Accuracy")
        plt.xticks(np.arange(len(bs_list_str)), bs_list_str, fontsize=12)
        # plt.legend()
        plt.savefig(r'result_image/{}_batch.jpg'.format(result[2]))
        self.openimage_label_image_show_batchsize(r'result_image/{}_batch.jpg'.format(result[2]))

        plt.cla()
        plt.figure(figsize=(3,2.25))
        models_list_str = result[0]
        plt.bar(np.arange(len(models_list_str)), np.array(result[1]), bar_width, align="center")
        plt.xlabel("Model")
        plt.ylabel("Accuracy")
        plt.xticks(np.arange(len(models_list_str)), models_list_str, fontsize=12)
        # plt.legend()
        plt.savefig(r'result_image/models_singlesource.jpg')
        self.openimage_label_image_show_models(r'result_image/models_singlesource.jpg')

        # {0: models_list, 1: acc_list_models_opt, 2: model_best_name_opt,3:best_batchsize_opt, 4: acc_list_epochs_best_opt,
        #  5: acc_list_batchsize_opt,6:best_epoch_opt,7: acc_list_models_sar, 8: model_best_name_sar,9:best_batchsize_sar,
        #  10: acc_list_epochs_best_sar, 11: acc_list_batchsize_sar,12:best_epoch_sar})

    def get_CNN_train_result_fugaishi_multisource(self, result):
        print(result)
        self.training_show.setText('Best Model with optical images:'+str(result[2])
                                   +'\n'+'Best batch size with optical images:'+str(result[3])
                                   +'\n'+'Best epoch with optical images:'+str(result[6][0][0]+1)
                                   +'\n'+'Best Model with SAR images:'+str(result[8])
                                   +'\n'+'Best batch size with SAR images:'+str(result[9])
                                   +'\n'+'Best epoch with SAR images:'+str(result[12][0][0]+1)
                                   )
        self.training_show.repaint()

        engine = pyttsx3.init()
        engine.say('已训练完毕，最优模型为')

        # engine.say(image_test_result[4])
        engine.runAndWait()
        ##设定batchsize,要与模型统一385,397行
        num_epochs = 10
        xxxx = np.arange(num_epochs) + 1
        z1 = np.polyfit(xxxx, result[4], 3)  # 用4次多项式拟合
        p1 = np.poly1d(z1)
        yvals1 = p1(xxxx)
        plot1_2 = plt.plot(xxxx, yvals1, 'b-p')
        plt.xlabel('Epoch')
        plt.ylabel('Accuracy rates')
        plt.savefig(r'result_image/so2sat_opt_{}_epoch.jpg'.format(result[2]))
        self.openimage_label_image_show_epochs('result_image/so2sat_opt_{}_epoch.jpg'.format(result[2]))

        plt.cla()
        bar_width = 0.5
        bs_list_str = list(['16', '32', '64', '128'])
        plt.bar(np.arange(len(bs_list_str)), np.array(result[5]), bar_width, align="center")
        plt.xlabel("Batch_size")
        plt.ylabel("Accuracy")
        plt.xticks(np.arange(len(bs_list_str)), bs_list_str, fontsize=12)
        # plt.legend()
        plt.savefig(r'result_image/so2sat_opt_{}_batch.jpg'.format(result[2]))
        self.openimage_label_image_show_batchsize(r'result_image/so2sat_opt_{}_batch.jpg'.format(result[2]))

        plt.cla()
        models_list_str = result[0]
        plt.bar(np.arange(len(models_list_str)), np.array(result[1]), bar_width, align="center")
        plt.xlabel("Model")
        plt.ylabel("Accuracy")
        plt.xticks(np.arange(len(models_list_str)), models_list_str, fontsize=12)
        # plt.legend()
        plt.savefig(r'result_image/so2sat_opt_models_multisource.jpg')
        self.openimage_label_image_show_models(r'result_image/so2sat_opt_models_multisource.jpg')

    def openimage_label_image_show_models(self, imgName):
        imgName = imgName.replace('\\', '/')
        jpg = QtGui.QPixmap(imgName)
        self.label_image_show_models.setPixmap(jpg)
        self.label_image_show_models.repaint()

    def openimage_label_image_show_batchsize(self, imgName):
        imgName = imgName.replace('\\', '/')
        jpg = QtGui.QPixmap(imgName)
        self.label_image_show_batchsize.setPixmap(jpg)
        self.label_image_show_batchsize.repaint()

    def openimage_label_image_show_epochs(self, imgName):
        imgName = imgName.replace('\\', '/')
        # jpg = QtGui.QPixmap(imgName)
        jpg = QtGui.QPixmap(imgName)
        self.label_image_show_epochs.setPixmap(jpg)
        self.label_image_show_epochs.repaint()
class Thread_CNN_train_fugaishi_singlesource(QThread):
    update_train_fugaishi_singlesource = pyqtSignal(dict)

    def __init__(self,
                 resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse,
                 alexnet_ifuse, mobilenet_ifuse, mstar_ifuse, uc_ifuse, fgsc23_ifuse, fusarship_ifuse,sortedcar_ifuse
                 ):
        super().__init__()

        self.resnet18_ifuse, self.resnet50_ifuse, self.vgg16_ifuse, self.vgg19_ifuse, self.densenet121_ifuse, self.squeezenet_ifuse, self.alexnet_ifuse, \
        self.mobilenet_ifuse, self.mstar_ifuse, self.uc_ifuse, self.fgsc23_ifuse, self.fusarship_ifuse,self.sortedcar_ifuse = \
            resnet18_ifuse, resnet50_ifuse, vgg16_ifuse, vgg19_ifuse, densenet121_ifuse, squeezenet_ifuse, \
            alexnet_ifuse, mobilenet_ifuse, mstar_ifuse, uc_ifuse, fgsc23_ifuse, fusarship_ifuse,sortedcar_ifuse

    def run(self):

        test_result = self.image_train_all()
        self.update_train_fugaishi_singlesource.emit(test_result)

    def image_train_all(self):
        models_list = []
        if self.resnet18_ifuse:
            models_list.append('resnet18')
        if self.resnet50_ifuse:
            models_list.append('resnet50')
        if self.vgg16_ifuse:
            models_list.append('vgg16')
        if self.vgg19_ifuse:
            models_list.append('vgg19')
        if self.densenet121_ifuse:
            models_list.append('densenet121')
        if self.squeezenet_ifuse:
            models_list.append('squeezenet')
        if self.alexnet_ifuse:
            models_list.append('alexnet')
        if self.mobilenet_ifuse:
            models_list.append('mobilenet')

        if self.mstar_ifuse:
            data_name = 'mstar'
            dataloders, dataset_sizes = self.load_mstar()
        elif self.uc_ifuse:
            data_name = 'uc'
            dataloders, dataset_sizes = self.load_uc()
        elif self.fusarship_ifuse:
            data_name = 'fusarship'
            dataloders, dataset_sizes = self.load_fusarship()
        elif self.fgsc23_ifuse:
            data_name = 'fgsc'
            dataloders, dataset_sizes = self.load_fgsc23()
        elif self.sortedcar_ifuse:
            data_name = 'sortedcar'
            dataloders, dataset_sizes = self.load_sortedcar()
        ##三个列表，分别为不同模型的最优正确率、最好模型不同batchsize正确率，不同batchsize训练的模型不同epochs正确率其存放为npy文件
        acc_list_models = []
        acc_list_batchsize = []
        acc_list_epochs_multibatchsize = []
        for model_name in models_list:
            print(model_name)
            model_ori = self.model_load(model=model_name, dataset=data_name)
            model_ori.to(device)
            model_finish, best_acc_models, _ = self.train_model(model_ori, dataloders, dataset_sizes, num_epochs=10)
            acc_list_models.append(best_acc_models.cpu())
            torch.save(model_finish, 'pths/{}_{}_batchsize16.pth'.format(data_name, model_name))
        model_best_name = models_list[acc_list_models.index(max(acc_list_models))]
        for batch_size in (16, 32, 64, 128, 256):
            print(batch_size)
            model_ori = self.model_load(model=model_best_name, dataset=data_name)
            model_ori.to(device)
            model_finish, best_acc_batchsize, acc_list_epochs = self.train_model(model_ori, dataloders, dataset_sizes,
                                                                                 num_epochs=10)
            torch.save(model_finish, 'pths/{}_{}_batchsize{}.pth'.format(data_name, model_best_name, batch_size))
            acc_list_batchsize.append(best_acc_batchsize.cpu())
            acc_list_epochs_multibatchsize.append(acc_list_epochs)
        batch_group = [16, 32, 64, 128, 256]
        best_batchsize = batch_group[acc_list_batchsize.index(max(acc_list_batchsize))]
        acc_list_epochs_best = acc_list_epochs_multibatchsize[acc_list_batchsize.index(max(acc_list_batchsize))]
        best_epoch = np.where(acc_list_epochs_best == np.max(acc_list_epochs_best))
        return (
        {0: models_list, 1: acc_list_models, 2: model_best_name,3:best_batchsize, 4: acc_list_epochs_best, 5: acc_list_batchsize,6:best_epoch})

    def train_model(self, model, dataloder, dataset_sizes, num_epochs=10):
        since = time.time()
        criterion = nn.CrossEntropyLoss()
        acc_list_epochs = np.zeros((num_epochs))
        # Observe that all parameters are being optimized
        optimizer = optim.Adam(model.parameters(), lr=0.001)
        best_model_wts = model.state_dict()
        best_acc = 0.0
        scheduler = lr_scheduler.StepLR(optimizer, step_size=19, gamma=0.9)
        for epoch in trange(num_epochs):
            print('Epoch {}/{}'.format(epoch + 1, num_epochs))
            print('-' * 10)

            # Each epoch has a training and validation phase
            for phase in ['train', 'val']:
                if phase == 'train':
                    scheduler.step()
                    model.train(True)  # Set model to training mode
                else:
                    model.train(False)  # Set model to evaluate mode
                    model.eval()

                running_loss = 0.0
                running_corrects = 0.0
                use_gpu = torch.cuda.is_available()
                # Iterate over data.
                for data in dataloder[phase]:
                    # get the inputs
                    inputs, labels = data
                    if use_gpu:
                        inputs = Variable(inputs.to(device))
                        labels = Variable(labels.to(device))
                    else:
                        inputs, labels = Variable(inputs), Variable(labels)

                    # zero the parameter gradients
                    optimizer.zero_grad()

                    # forward
                    outputs = model(inputs)
                    _, preds = torch.max(outputs.data, 1)
                    loss = criterion(outputs, labels)

                    # backward + optimize only if in training phase
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()

                    # statistics
                    running_loss += loss.item()
                    running_corrects += torch.sum(preds == labels.data).to(torch.float32)

                epoch_loss = running_loss / dataset_sizes[phase]
                epoch_acc = running_corrects / dataset_sizes[phase]
                acc_list_epochs[epoch] = epoch_acc
                print('{} Loss: {:.4f} Acc: {:.4f}'.format(
                    phase, epoch_loss, epoch_acc))

                # deep copy the model
                if phase == 'val' and epoch_acc > best_acc:
                    best_acc = epoch_acc
                    best_model_wts = model.state_dict()
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
            time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))

        # load best model weights
        model.load_state_dict(best_model_wts)
        return model, best_acc, acc_list_epochs

    def model_load(self, model='vgg16', dataset='mstar', ifpretrained=True):
        if model == 'vgg16':
            if dataset == 'mstar':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        if model == 'vgg19':
            if dataset == 'mstar':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet18':
            if dataset == 'mstar':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'uc':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)
            elif dataset == 'fusarship':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'sortedcar':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'fgsc':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 17)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet50':
            if dataset == 'mstar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'uc':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)

            elif dataset == 'fusarship':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'sortedcar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'fgsc':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 17)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'squeezenet':
            if dataset == 'mstar':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 10, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'uc':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 21, kernel_size=(1, 1), stride=(1, 1))

            elif dataset == 'fusarship':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 4, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'sortedcar':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 4, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'fgsc':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 17, kernel_size=(1, 1), stride=(1, 1))
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'alexnet':
            if dataset == 'mstar':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'densenet201':
            if dataset == 'mstar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'inceptionv3':
            if dataset == 'mstar':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 10)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 21)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 4)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 4)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 17)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'mnasnet1_0':
            if dataset == 'mstar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'mobilenet':
            if dataset == 'mstar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'shufflenet_v2':
            if dataset == 'mstar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=10, bias=True)
            elif dataset == 'uc':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=21, bias=True)

            elif dataset == 'fusarship':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        else:
            print('Wrong input, check again please')

        return model_ft

    def load_mstar(self, model='vgg16', batch_size=16):
        data_transforms = {
            'train': transforms.Compose([
                transforms.Grayscale(1),
                transforms.Resize(128),
                transforms.CenterCrop(128),
                transforms.RandomHorizontalFlip(),
                transforms.ToTensor(),
                transforms.Normalize((0.184,), (0.119,))

            ]),
            'val': transforms.Compose([
                transforms.Grayscale(1),
                transforms.Resize(128),
                transforms.CenterCrop(128),
                transforms.ToTensor(),
                transforms.Normalize((0.184,), (0.119,))

            ])
        }
        data_dir = 'Data\\Targets\\MSTAR-10'
        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        train_len = len(image_datasets['train'])
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=16,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes

    def load_uc(self, model='vgg16', batch_size=16):

        data_transforms = {
            "train": transforms.Compose([transforms.RandomResizedCrop(224),
                                         transforms.RandomHorizontalFlip(),
                                         transforms.ToTensor(),
                                         transforms.Normalize((0.44979182, 0.48921227, 0.48212156),
                                                              (0.19673954, 0.20322968, 0.21901236))]),
            "val": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.44979182, 0.48921227, 0.48212156),
                                                            (0.19673954, 0.20322968, 0.21901236))])}

        data_dir = 'Data\\Scene\\UCMerced_LandUse'

        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=16,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes

    def load_fgsc23(self, model='vgg16', batch_size=16):

        data_transforms = {
            "train": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.352978, 0.373653, 0.359517), (0.4979, 0.4846, 0.4829))]),
            "val": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.352978, 0.373653, 0.359517), (0.4979, 0.4846, 0.4829))])}

        data_dir = 'Data\\Targets\\FGSC-23'

        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=16,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes
    def load_fusarship(self, model='vgg16', batch_size=16):

        data_transforms = {
            "train": transforms.Compose([
                transforms.Grayscale(1),
                transforms.CenterCrop(512),
                transforms.ToTensor(),
            ]),
            "val": transforms.Compose([
                transforms.Grayscale(1),
                transforms.CenterCrop(512),
                transforms.ToTensor(),
            ])}

        data_dir = 'Data\\Targets\\FUSAR_Ship'

        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=4,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes
    def load_sortedcar(self, model='vgg16', batch_size=16):

        data_transforms = {
            "train": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.500798, 0.487246, 0.446257), (0.3841, 0.3740,  0.3781))]),
            "val": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.500798, 0.487246, 0.446257), (0.3841, 0.3740,  0.3781))])}

        data_dir = 'Data\\Scene\\AID'

        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=16,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes
class Thread_CNN_train_fugaishi_multisource(QThread):
    update_train_fugaishi_multisource = pyqtSignal(dict)

    def __init__(self,
                 resnet18_ifuse_2, resnet50_ifuse_2, vgg16_ifuse_2, vgg19_ifuse_2, densenet121_ifuse_2, squeezenet_ifuse_2,
                 alexnet_ifuse_2, mobilenet_ifuse_2, so2sat_ifuse
                 ):
        super().__init__()

        self.resnet18_ifuse_2, self.resnet50_ifuse_2, self.vgg16_ifuse_2, self.vgg19_ifuse_2, self.densenet121_ifuse_2, self.squeezenet_ifuse_2,self.alexnet_ifuse_2, self.mobilenet_ifuse_2, self.so2sat_ifuse = \
            resnet18_ifuse_2, resnet50_ifuse_2, vgg16_ifuse_2, vgg19_ifuse_2, densenet121_ifuse_2, squeezenet_ifuse_2,alexnet_ifuse_2, mobilenet_ifuse_2, so2sat_ifuse

    def run(self):

        test_result = self.image_train_all()
        self.update_train_fugaishi_multisource.emit(test_result)

    def image_train_all(self):
        models_list = []
        if self.resnet18_ifuse_2:
            models_list.append('resnet18')
        if self.resnet50_ifuse_2:
            models_list.append('resnet50')
        if self.vgg16_ifuse_2:
            models_list.append('vgg16')
        if self.vgg19_ifuse_2:
            models_list.append('vgg19')
        if self.densenet121_ifuse_2:
            models_list.append('densenet121')
        if self.squeezenet_ifuse_2:
            models_list.append('squeezenet')
        if self.alexnet_ifuse_2:
            models_list.append('alexnet')
        if self.mobilenet_ifuse_2:
            models_list.append('mobilenet')

        if self.so2sat_ifuse:
            data_name = 'so2sat'
            dataloders_opt,dataloders_sar, dataset_sizes = self.load_so2sat()

        ##三个列表，分别为不同模型的最优正确率、最好模型不同batchsize正确率，不同batchsize训练的模型不同epochs正确率其存放为npy文件
        acc_list_models_opt = []
        acc_list_batchsize_opt = []
        acc_list_epochs_multibatchsize_opt = []
        for model_name in models_list:
            print(model_name)
            model_ori = self.model_load(model=model_name, dataset='so2satopt')
            model_ori.to(device)
            model_finish, best_acc_models, _ = self.train_model(model_ori, dataloders_opt, dataset_sizes, num_epochs=10)
            acc_list_models_opt.append(best_acc_models.cpu())
            torch.save(model_finish, 'pths/{}_{}_batchsize16.pth'.format(data_name, model_name))
        model_best_name_opt = models_list[acc_list_models_opt.index(max(acc_list_models_opt))]
        for batch_size in (16, 32, 64, 128, 256):
            dataloders_opt,_, dataset_sizes = self.load_so2sat(batch_size=batch_size)
            model_ori_opt = self.model_load(model=model_best_name_opt, dataset='so2satopt')
            model_ori_opt.to(device)
            model_finish, best_acc_batchsize_opt, acc_list_epochs_opt = self.train_model(model_ori_opt, dataloders_opt, dataset_sizes,
                                                                                 num_epochs=10)
            torch.save(model_finish, 'pths/{}_{}_batchsize{}.pth'.format(data_name, model_best_name_opt, batch_size))
            acc_list_batchsize_opt.append(best_acc_batchsize_opt.cpu())
            acc_list_epochs_multibatchsize_opt.append(acc_list_epochs_opt)

        batch_group = [16, 32, 64, 128, 256]
        best_batchsize_opt = batch_group[acc_list_batchsize_opt.index(max(acc_list_batchsize_opt))]
        acc_list_epochs_best_opt = acc_list_epochs_multibatchsize_opt[acc_list_batchsize_opt.index(max(acc_list_batchsize_opt))]
        best_epoch_opt = np.where(acc_list_epochs_best_opt == np.max(acc_list_epochs_best_opt))

        print(models_list, acc_list_models_opt, model_best_name_opt, best_acc_batchsize_opt, acc_list_epochs_best_opt,
              acc_list_batchsize_opt)

        ##三个列表，分别为不同模型的最优正确率、最好模型不同batchsize正确率，不同batchsize训练的模型不同epochs正确率其存放为npy文件
        acc_list_models_sar = []
        acc_list_batchsize_sar = []
        acc_list_epochs_multibatchsize_sar = []
        for model_name in models_list:
            print(model_name)
            model_ori_sar = self.model_load(model=model_name, dataset='so2satsar')
            model_ori_sar.to(device)
            model_finish, best_acc_models, _ = self.train_model(model_ori_sar, dataloders_sar, dataset_sizes, num_epochs=10)
            acc_list_models_sar.append(best_acc_models.cpu())
            torch.save(model_finish, 'pths/{}_{}_batchsize16.pth'.format(data_name, model_name))
        model_best_name_sar = models_list[acc_list_models_sar.index(max(acc_list_models_sar))]
        for batch_size in (16, 32, 64, 128, 256):
            _,dataloders_sar, dataset_sizes = self.load_so2sat(batch_size=batch_size)
            model_ori_sar = self.model_load(model=model_best_name_sar, dataset='so2satsar')
            model_ori_sar.to(device)
            model_finish_sar, best_acc_batchsize_sar, acc_list_epochs_sar = self.train_model(model_ori_sar, dataloders_sar, dataset_sizes,num_epochs=10)
            torch.save(model_finish, 'pths/{}_{}_batchsize{}.pth'.format(data_name, model_best_name_sar, batch_size))
            acc_list_batchsize_sar.append(best_acc_batchsize_sar.cpu())
            acc_list_epochs_multibatchsize_sar.append(acc_list_epochs_sar)

        batch_group = [16, 32, 64, 128, 256]
        best_batchsize_sar = batch_group[acc_list_batchsize_sar.index(max(acc_list_batchsize_sar))]
        acc_list_epochs_best_sar = acc_list_epochs_multibatchsize_opt[acc_list_batchsize_sar.index(max(acc_list_batchsize_sar))]
        best_epoch_sar = np.where(acc_list_epochs_best_sar == np.max(acc_list_epochs_best_sar))


        print(models_list, acc_list_models_sar, model_best_name_sar, best_acc_batchsize_sar, acc_list_epochs_best_sar,
              acc_list_batchsize_sar)

        return (
        {0: models_list, 1: acc_list_models_opt, 2: model_best_name_opt,3:best_batchsize_opt, 4: acc_list_epochs_best_opt,
         5: acc_list_batchsize_opt,6:best_epoch_opt,7: acc_list_models_sar, 8: model_best_name_sar,9:best_batchsize_sar,
         10: acc_list_epochs_best_sar, 11: acc_list_batchsize_sar,12:best_epoch_sar})

    def train_model(self, model, dataloder, dataset_sizes, num_epochs=10):
        since = time.time()
        criterion = nn.CrossEntropyLoss()
        acc_list_epochs = np.zeros((num_epochs))
        # Observe that all parameters are being optimized
        optimizer = optim.Adam(model.parameters(), lr=0.001)
        best_model_wts = model.state_dict()
        best_acc = 0.0
        scheduler = lr_scheduler.StepLR(optimizer, step_size=19, gamma=0.9)
        for epoch in trange(num_epochs):
            print('Epoch {}/{}'.format(epoch + 1, num_epochs))
            print('-' * 10)

            # Each epoch has a training and validation phase
            for phase in ['train', 'val']:
                if phase == 'train':
                    scheduler.step()
                    model.train(True)  # Set model to training mode
                else:
                    model.train(False)  # Set model to evaluate mode
                    model.eval()

                running_loss = 0.0
                running_corrects = 0.0
                use_gpu = torch.cuda.is_available()
                # Iterate over data.
                for data in dataloder[phase]:
                    # get the inputs
                    inputs, labels = data
                    if use_gpu:
                        inputs = Variable(inputs.to(torch.float32).to(device))
                        labels = Variable(labels.to(device))
                    else:
                        inputs, labels = Variable(inputs), Variable(labels)

                    # zero the parameter gradients
                    optimizer.zero_grad()

                    # forward
                    outputs = model(inputs)
                    _, preds = torch.max(outputs.data, 1)
                    loss = criterion(outputs, labels)

                    # backward + optimize only if in training phase
                    if phase == 'train':
                        loss.backward()
                        optimizer.step()

                    # statistics
                    running_loss += loss.item()
                    running_corrects += torch.sum(preds == labels.data).to(torch.float32)

                epoch_loss = running_loss / dataset_sizes[phase]
                epoch_acc = running_corrects / dataset_sizes[phase]
                acc_list_epochs[epoch] = epoch_acc
                print('{} Loss: {:.4f} Acc: {:.4f}'.format(
                    phase, epoch_loss, epoch_acc))

                # deep copy the model
                if phase == 'val' and epoch_acc > best_acc:
                    best_acc = epoch_acc
                    best_model_wts = model.state_dict()
        time_elapsed = time.time() - since
        print('Training complete in {:.0f}m {:.0f}s'.format(
            time_elapsed // 60, time_elapsed % 60))
        print('Best val Acc: {:4f}'.format(best_acc))

        # load best model weights
        model.load_state_dict(best_model_wts)
        return model, best_acc, acc_list_epochs

    def model_load(self, model='vgg16', dataset='mstar', ifpretrained=True):
        if model == 'vgg16':
            if dataset == 'mstar':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.vgg16(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        if model == 'vgg19':
            if dataset == 'mstar':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.vgg16(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.vgg19(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.vgg19(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet18':
            if dataset == 'mstar':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'so2satsar':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'uc':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)
            elif dataset == 'so2satopt':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'fusarship':
                model_ft = models.resnet18(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'sortedcar':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'fgsc':
                model_ft = models.resnet18(pretrained=True)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 17)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'resnet50':
            if dataset == 'mstar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 10)
            elif dataset == 'so2satsar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'uc':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 21)
            elif dataset == 'so2satopt':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 5)
            elif dataset == 'fusarship':
                model_ft = models.resnet50(pretrained=ifpretrained)
                model_ft.conv1 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'sortedcar':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 4)
            elif dataset == 'fgsc':
                model_ft = models.resnet50(pretrained=ifpretrained)
                num_ftrs = model_ft.fc.in_features
                model_ft.fc = nn.Linear(num_ftrs, 17)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'squeezenet':
            if dataset == 'mstar':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 10, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'so2satsar':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 5, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'uc':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 21, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'so2satopt':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 5, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'fusarship':
                model_ft = models.squeezenet1_0(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 96, kernel_size=(7, 7), stride=(2, 2))
                model_ft.classifier[1] = nn.Conv2d(512, 4, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'sortedcar':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 4, kernel_size=(1, 1), stride=(1, 1))
            elif dataset == 'fgsc':
                model_ft = models.squeezenet1_0(pretrained=True)
                model_ft.classifier[1] = nn.Conv2d(512, 17, kernel_size=(1, 1), stride=(1, 1))
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'alexnet':
            if dataset == 'mstar':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.alexnet(pretrained=ifpretrained)
                model_ft.features[0] = nn.Conv2d(1, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.alexnet(pretrained=True)
                model_ft.classifier[6] = nn.Linear(in_features=4096, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'densenet121':
            if dataset == 'mstar':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=10, bias=True)
            if dataset == 'so2satsar':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.densenet121(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1024, out_features=5, bias=True)

            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'densenet201':
            if dataset == 'mstar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.features.conv0 = nn.Conv2d(1, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3),
                                                    bias=False)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.densenet201(pretrained=ifpretrained)
                model_ft.classifier = nn.Linear(in_features=1920, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'inceptionv3':
            if dataset == 'mstar':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 10)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 10)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 21)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 21)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.inception_v3(pretrained=True, transform_input=False)
                model_ft.Conv2d_1a_3x3.conv = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), bias=False)
                model_ft.AuxLogits.fc = nn.Linear(768, 4)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 4)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.inception_v3(pretrained=ifpretrained)
                model_ft.AuxLogits.fc = nn.Linear(2048, 17)
                model_ft.aux_logits = False
                model_ft.fc = nn.Linear(in_features=2048, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')

        elif model == 'mnasnet1_0':
            if dataset == 'mstar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.layers[0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.mnasnet1_0(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'mobilenet':
            if dataset == 'mstar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.features[0][0] = nn.Conv2d(1, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1),
                                                    bias=False)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.mobilenet_v2(pretrained=ifpretrained)
                model_ft.classifier[1] = nn.Linear(in_features=1280, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        elif model == 'shufflenet_v2':
            if dataset == 'mstar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=10, bias=True)
            elif dataset == 'so2satsar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=5, bias=True)
            elif dataset == 'uc':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=21, bias=True)
            elif dataset == 'so2satopt':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=5, bias=True)
            elif dataset == 'fusarship':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.conv1[0] = nn.Conv2d(1, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
                model_ft.fc = nn.Linear(in_features=1024, out_features=4, bias=True)
            elif dataset == 'sortedcar':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=4, bias=True)
            elif dataset == 'fgsc':
                model_ft = models.shufflenet_v2_x1_0(pretrained=ifpretrained)
                model_ft.fc = nn.Linear(in_features=1024, out_features=17, bias=True)
            else:
                print('Only support UC and MSTAR in this module')
        else:
            print('Wrong input, check again please')

        return model_ft

    def load_so2sat(self, model='vgg16', batch_size=16):
        x_train_opt = np.load('Data\\so2sat\\20000rgb5.npy')
        x_train_sar = np.load('Data\\so2sat\\20000vvfilter5.npy')
        y_train = np.load('Data\\so2sat\\20000lab0-5.npy')


        x_val_opt = np.load('Data\\so2sat\\10608rgb5.npy')
        x_val_sar = np.load('Data\\so2sat\\10608vvfilter5.npy')
        y_val = np.load('Data\\so2sat\\10607testlab0-5.npy')

        x_train_opt = np.transpose(x_train_opt, (0, 3, 1, 2))
        x_val_opt = np.transpose(x_val_opt, (0, 3, 1, 2))

        x_train_sar = x_train_sar[:, :, :, np.newaxis]
        x_val_sar = x_val_sar[:, :, :, np.newaxis]
        x_train_sar = np.transpose(x_train_sar, (0, 3, 1, 2))
        x_val_sar = np.transpose(x_val_sar, (0, 3, 1, 2))

        a = torch.from_numpy(x_train_opt)
        b = torch.from_numpy(y_train)
        c = torch.from_numpy(x_val_opt)
        d = torch.from_numpy(y_val)
        train_opt_ids = TensorDataset(a, b)
        train_loader_opt = DataLoader(dataset=train_opt_ids, batch_size=1024, shuffle=True)
        val_opt_ids = TensorDataset(c, d)
        val_loader_opt = DataLoader(dataset=val_opt_ids, batch_size=1024, shuffle=False)
        dataloaders_opt = {'train':train_loader_opt,'val':val_loader_opt}

        m = torch.from_numpy(x_train_sar)
        n = torch.from_numpy(x_val_sar)
        train_sar_ids = TensorDataset(m, b)
        train_loader_sar = DataLoader(dataset=train_sar_ids, batch_size=1024, shuffle=True)
        val_sar_ids = TensorDataset(n, d)
        val_loader_sar = DataLoader(dataset=val_sar_ids, batch_size=1024, shuffle=False)
        dataloaders_sar = {'train':train_loader_sar,'val':val_loader_sar}

        dataset_sizes = {'train':len(train_sar_ids), 'val':len(val_sar_ids)}
        return dataloaders_opt,dataloaders_sar, dataset_sizes

    def load_uc(self, model='vgg16', batch_size=16):

        data_transforms = {
            "train": transforms.Compose([transforms.Resize((224, 224)),
                                         transforms.RandomHorizontalFlip(),
                                         transforms.ToTensor(),
                                         transforms.Normalize((0.44979182, 0.48921227, 0.48212156),
                                                              (0.19673954, 0.20322968, 0.21901236))]),
            "val": transforms.Compose([transforms.Resize((224, 224)),
                                       transforms.ToTensor(),
                                       transforms.Normalize((0.44979182, 0.48921227, 0.48212156),
                                                            (0.19673954, 0.20322968, 0.21901236))])}

        data_dir = 'Data\\Scene\\UCMerced_LandUse'

        image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
                                                  data_transforms[x]) for x in ['train', 'val']}
        # wrap your data and label into Tensor
        dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],
                                                     batch_size=16,
                                                     shuffle=True,
                                                     num_workers=4) for x in ['train', 'val']}

        dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
        return dataloders, dataset_sizes

def write_excel_xlsx(path, value):
    index = len(value)
    # 打开excel
    xl = load_workbook(path)
    # 获取所有sheet页名字
    xl_sheet_names = xl.get_sheet_names()
    # 定位到相应sheet页,[0]为sheet页索引
    xl_sheet = xl.get_sheet_by_name(xl_sheet_names[0])
    # 获取行列数
    row = xl_sheet.max_row
    if row == 0:
        ge = -2
    else:
        ge = 2
    # sheet.title = sheet_name
    for i in range(0, index):
        xl_sheet.cell(row=i + ge + row, column=1, value=str(value[i]))
    xl.save(path)
    print("Write in xlsx file!")


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    train = QtWidgets.QDialog()
    ui = Ui_Form_train_fugaishi()
    ui.setupUi(train)
    ui.caolianjie()
    train.show()
    sys.exit(app.exec_())
